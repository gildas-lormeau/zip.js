<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>zip.js - Core API</title>
	<meta name="viewport" content="width=device-width">
	<meta name="description" content="Core API of zip.js">
	<link rel="stylesheet" href="default.css">
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
	<link href="https://fonts.googleapis.com/css?family=Maven+Pro|Muli|Istok+Web" rel="stylesheet" type="text/css">
</head>

<body>
	<a href="https://github.com/gildas-lormeau/zip.js" class="github-corner" aria-label="View source on GitHub"><svg
			width="80" height="80" viewBox="0 0 250 250"
			style="fill: #202020;color: #a69373;position: absolute;top: 0;border: 0;right: 0;" aria-hidden="true">
			<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
			<path
				d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
				fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
			<path
				d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
				fill="currentColor" class="octo-body"></path>
		</svg></a>
	<div id="container">
		<h1>
			<a href="index.html">zip.js</a> <span class="small"></span>
		</h1>

		<div class="description">
			Core API
			<hr>
		</div>
		<h2>Contents</h2>
		<ol>
			<li><a href="#installation">Installation</a></li>
			<li><a href="#configuration">Configuration</a></li>
			<li><a href="#io">Input/output classes</a></li>
			<li><a href="#zip-reading">ZipReader class</a></li>
			<li><a href="#zip-reading-example">ZipReader example</a></li>
			<li><a href="#zip-writing">ZipWriter class</a></li>
			<li><a href="#zip-writing-example">ZipWriter example</a></li>
			<li><a href="#full-example">Full example</a></li>
			<li><a href="#alternative-codecs">Alternative DEFLATE implementations</a></li>
		</ol>
		<hr>

		<h2 id="installation">Installation</h2>
		<ul>
			<li>Import zip.js in your project:
				<ul>
					<li>
						To install the library with <a href="https://www.npmjs.com/package/@zip.js/zip.js">NPM</a>, run:
						<pre><code class="prettyprint">npm install @zip.js/zip.js</code></pre>
						Then, you can import it as a JavaScript module in your project and bundle it with your favorite
						tools:
						<ul>
							<li>as an ES6 module imported with <code>import</code>
								<pre><code class="prettyprint">import * as zip from "@zip.js/zip.js";</code></pre>
							</li>
							<li>or as a CommonJS module imported with <code>require</code>
								<pre><code class="prettyprint">const zip = require("@zip.js/zip.js");</code></pre>
							</li>
						</ul>
					</li>
					<li>
						To install zip.js manually, add <code>zip.min.js</code> from the
						<code><a href="https://github.com/gildas-lormeau/zip.js/tree/master/dist" target="repository">/dist</a></code>
						directory in your project. If you don't want to use web workers, add
						<code>zip-full.min.js</code> instead. Then, include <code>zip.min.js</code> (or
						<code>zip-full.min.js</code>) in your HTML page:
						<ul>
							<li>as a regular script
								<pre><code class="prettyprint">&lt;script type=&quot;text/javascript&quot; src=&quot;/library_path/zip.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // the zip API is in window.zip
  // ...
&lt;/script&gt;</code></pre>
							</li>
							<li>or as an AMD module
								<pre><code class="prettyprint">require(["/library_path/zip.min.js"], zip => {
  // ...
});</code></pre>

							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>If you don't want to use <a href="https://www.w3.org/TR/workers/">Web workers</a>, configure zip.js with
				<code>useWebWorkers</code> set to <code>false</code>
				<pre><code class="prettyprint">zip.configure({
  useWebWorkers: false
});</code></pre>
			</li>
		</ul>

		<h2 id="configuration">Configuration</h2>
		<p>You can call the function <code>zip.configure</code> in order to configure zip.js. It accepts a configuration
			object as parameter with these optional properties:</p>
		<dl>
			<dt><code>useWebWorkers (boolean)</code></dt>
			<dd>Enables the use of <a href="https://www.w3.org/TR/workers/">Web workers</a> to compress and uncompress
				data in non-blocking background processes. The default value is <code>true</code>.
			</dd>
		</dl>
		<dl>
			<dt><code>terminateWorkerTimeout (number)</code></dt>
			<dd>Delay before terminating a web worker in ms. The default value is <code>5000</code>. You can call
				<code>zip.terminateWorkers()</code> to terminate idle workers.
			</dd>
		</dl>
		<dl>
			<dt><code>maxWorkers (number)</code></dt>
			<dd>Number of workers used simultaneously to process data. The default value is the number of logical
				cores returned by the attribute
				<code><a href="https://html.spec.whatwg.org/multipage/workers.html#navigator.hardwareconcurrency">navigator.hardwareConcurrency</a></code>
				or <code>2</code> if <code>navigator</code> is <code>undefined</code>.
			</dd>
		</dl>
		<dl>
			<dt><code>workerScripts (Object)</code></dt>
			<dd>Advanced option to explicitly control which scripts are loaded in the web worker. It allows using
				alternative deflate implementations or specifying a URL to the worker script if the CSP of the page
				blocks scripts imported with a Blob URL.
				<br>
				The properties <code>deflate</code> and <code>inflate</code> must specify arrays of URLs to import
				the deflate/inflate scripts, respectively. The first URL is relative to the base URI of the document.
				The other URLs are relative to the URL of the first script. Scripts in the array are executed in order.
				If only deflation or inflation is used in your application, the unused
				<code>workerScripts.deflate/inflate</code> property can be omitted. Example:
				<pre><code class="prettyprint">zip.configure({
  workerScripts: {
    deflate: ["library_path/custom-worker.js", "./custom-deflate.js"],
    inflate: ["library_path/custom-worker.js", "./custom-inflate.js"]
  }
});</code></pre>
				You can use this property if the CSP of the page blocks scripts imported with a Blob URL. For this, you
				have to add <code>z-worker.js</code> from the
				<code><a href="https://github.com/gildas-lormeau/zip.js/tree/master/dist" target="repository">/dist</a></code>
				directory in your project and specify the URL where it can be found in your project. Example:
				<pre><code class="prettyprint">zip.configure({
  workerScripts: {
    deflate: ["library_path/z-worker.js"],
    inflate: ["library_path/z-worker.js"]
  }
});</code></pre>
			</dd>
		</dl>

		<h2 id="io">Input/output classes</h2>
		<h3>Reader and Writer constructors</h3>
		<p>
			<code>zip.js</code> can handle multiple types of data thanks to a generic API. This feature is based on 2
			abstract constructors: <code><a href="#zip-reading">zip.Reader</a></code> and
			<code><a href="#zip-writer">zip.Writer</a></code>. The <code><a href="#zip-reading">zip.Reader</a></code>
			constructors help to read data from a source of data. The <code><a href="#zip-writer">zip.Writer</a></code>
			constructors help to write data into a destination.
		</p>
		<p>
			For example, if you need to read a zip and store a uncompressed file into a variable, you must use a
			<code><a href="#zip-reading">zip.Reader</a></code> object to read the compressed zip data. You must also use
			a <code><a href="#zip-writer">zip.Writer</a></code> object to write the uncompressed file data into the
			variable.
		</p>

		<h3>Reader constructors</h3>

		<p>
			<code>string</code> reader constructor
		</p>
		<pre><code class="prettyprint">zip.TextReader(text)</code></pre>
		<p>Parameters:</p>
		<dl>
			<dt><code>text (string)</code></dt>
			<dd>The <code>string</code> to read</dd>
		</dl>
		<br>
		<p>
			<code><a href="https://www.w3.org/TR/FileAPI/#dfn-Blob">Blob</a></code> object reader constructor
		</p>
		<pre><code class="prettyprint">zip.BlobReader(blob)</code></pre>
		<p>Parameters:</p>
		<dl>
			<dt><code>blob (<a href="https://www.w3.org/TR/FileAPI/#dfn-Blob">Blob</a>)</code></dt>
			<dd>The <code><a href="https://www.w3.org/TR/FileAPI/#dfn-Blob">Blob</a></code> object to read</dd>
		</dl>
		<br>
		<p>
			<code><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">Uint8Array</a></code>
			object reader constructor
		</p>
		<pre><code class="prettyprint">zip.Uint8ArrayReader(array)</code></pre>
		<p>Parameters:</p>
		<dl>
			<dt><code>array (<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">Uint8Array</a>)</code>
			</dt>
			<dd>The
				<code><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">Uint8Array</a></code>
				array to read
			</dd>
		</dl>
		<br>
		<p>
			Data URI reader constructor
		</p>
		<pre><code class="prettyprint">zip.Data64URIReader(dataURI)</code></pre>
		<p>Parameters:</p>
		<dl>
			<dt><code>dataURI (string)</code></dt>
			<dd>The data URI to read</dd>
		</dl>
		<br>
		<p>
			HTTP content reader constructor
		</p>
		<pre><code class="prettyprint">zip.HttpReader(URL [, options])</code></pre>
		<p>Parameters:</p>
		<dl>
			<dt><code>URL (string)</code></dt>
			<dd>The URL of the content to read</dd>
			<dt><code>options (Object)</code></dt>
			<dd>Optional properties:
				<dl>
					<dt><code>useRangeHeader (boolean)</code></dt>
					<dd>boolean value specifying if the <code>Range</code> request header should be used
						(<code>false</code> by default)</dd>
					<dt><code>preventHeadRequest (boolean)</code></dt>
					<dd>boolean value specifying if a <code>HEAD</code> request can be sent in order the get the content
						length (<code>false</code> by default)</dd>
					<dt><code>forceRangeRequests (boolean)</code></dt>
					<dd>boolean value specifying if the <code>Range</code> request header should be sent even if the
						server does not send responses with the header <code>Accept-Ranges: bytes</code>
						(<code>false</code> by default)</dd>
					<dt><code>useXHR (boolean)</code></dt>
					<dd>boolean value specifying if the implementation should rely on the <a
							href="https://xhr.spec.whatwg.org/"><code>XMLHttpRequest</code></a>
						API instead of the <a href="https://fetch.spec.whatwg.org/"><code>fetch</code></a> API to send
						requests (<code>false</code> by default)</dd>
				</dl>
				If <code>useXHR</code> is not set to <code>true</code>, you can additionnally pass any option the
				<a href="https://fetch.spec.whatwg.org/"><code>fetch</code></a> API accepts.
			</dd>
		</dl>
		<br>
		<p>
			HTTP content reader using <code>Range</code> request header constructor
		</p>
		<pre><code class="prettyprint">zip.HttpRangeReader(URL [, options])</code></pre>
		<p>Parameters:</p>
		<dl>
			<dt><code>URL (string)</code></dt>
			<dd>The URL of the content to read</dd>
			<dt><code>options (Object)</code></dt>
			<dd>Optional properties:
				<dl>
					<dt><code>forceRangeRequests (boolean)</code></dt>
					<dd>boolean value specifying if the <code>Range</code> request header should be sent even if the
						server does not send responses with the header <code>Accept-Ranges: bytes</code>
						(<code>false</code> by default)</dd>
					<dt><code>useXHR (boolean)</code></dt>
					<dd>boolean value specifying if the implementation should rely on the <a
							href="https://xhr.spec.whatwg.org/"><code>XMLHttpRequest</code></a>
						API instead of the <a href="https://fetch.spec.whatwg.org/"><code>fetch</code></a> API to send
						requests (<code>false</code> by default)</dd>
				</dl>
				If <code>useXHR</code> is not set to <code>true</code>, you can additionnally pass any option the
				<a href="https://fetch.spec.whatwg.org/"><code>fetch</code></a> API accepts.
			</dd>
		</dl>

		<h3>Reader members (used internally)</h3>
		<h4>Attributes</h4>
		<dl>
			<dt><code>size (number)</code></dt>
			<dd>The size of data to read in bytes</dd>
		</dl>
		<br>
		<h4>Methods</h4>
		<pre><code class="prettyprint">zip.Reader#init()</code></pre>
		<p>Initialize the <code><a href="#zip-reading">zip.Reader</a></code> object</p>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with <code>undefined</code> as resolved value</dd>
		</dl>
		<br>
		<pre><code class="prettyprint">zip.Reader#readUint8Array(index, length])</code></pre>
		<p>Extract an
			<code><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">UInt8Array</a></code>
			object beginning at <code>index</code> location through the specified <code>length</code>
		</p>
		<p>Parameters:</p>
		<dl>
			<dt><code>index (number)</code></dt>
			<dd>The beginning index</dd>
			<dt><code>length (number)</code></dt>
			<dd>The
				<code><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">UInt8Array</a></code>
				object
				length
			</dd>
		</dl>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with the
				<code><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">UInt8Array</a></code>
				object as resolved value
			</dd>
		</dl>
		<h3>Writer constructors</h3>
		<p>
			<code>string</code> writer constructor
		</p>
		<pre><code class="prettyprint">zip.TextWriter()</code></pre>
		<br>
		<p>
			<code><a href="https://www.w3.org/TR/FileAPI/#dfn-Blob">Blob</a></code> object writer constructor
		</p>
		<pre><code class="prettyprint">zip.BlobWriter([mimeString])</code></pre>
		<p>Parameters:</p>
		<dl>
			<dt><code>mimeString (string)</code></dt>
			<dd>The MIME type of the data to write</dd>
		</dl>
		<br>
		<p>
			<code><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">Uint8Array</a></code>
			object writer constructor
		</p>
		<pre><code class="prettyprint">zip.Uint8ArrayWriter()</code></pre>
		<br>
		<p>
			Data URI writer constructor
		</p>
		<pre><code class="prettyprint">zip.Data64URIWriter([mimeString])</code></pre>
		<p>Parameters:</p>
		<dl>
			<dt><code>mimeString (string)</code></dt>
			<dd>The MIME type of the data to write</dd>
		</dl>

		<h3>Writer members (used internally)</h3>
		<h4>Attributes</h4>
		<dl>
			<dt><code>size (number)</code></dt>
			<dd>The size of written data in bytes</dd>
		</dl>
		<br>
		<h4>Methods</h4>
		<pre><code class="prettyprint">zip.Writer#init()</code></pre>
		<p>Initialize the <code><a href="#zip-writer">zip.Writer</a></code> object</p>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with <code>undefined</code> as resolved value</dd>
		</dl>
		<br>
		<pre><code class="prettyprint">zip.Writer#writeUint8Array(array)</code></pre>
		<p>Write an
			<code><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">UInt8Array</a></code>
			object at the current index
		</p>
		<p>Parameters:</p>
		<dl>
			<dt><code>array (<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">UInt8Array</a>)</code>
			</dt>
			<dd>The
				<code><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects">UInt8Array</a></code>
				to write
			</dd>
		</dl>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with <code>undefined</code> as resolved value</dd>
		</dl>
		<br>
		<pre><code class="prettyprint">zip.Writer#getData()</code></pre>
		<p>Get written data (returned type depends on <code><a href="#zip-reading">zip.Reader</a></code> constructor
			used)</p>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with the data as resolved value</dd>
		</dl>
		<h2 id="zip-reading">ZipReader class</h2>
		<h3>Constructor</h3>
		<pre><code class="prettyprint">zip.ZipReader(reader [, options])</code></pre>
		<p>
			Create a <code><a href="#zip-reading">ZipReader</a></code> object. A
			<code><a href="#zip-reading">ZipReader</a></code> object helps to read the zipped content.
		</p>
		<p>Parameters:</p>
		<dl>
			<dt><code>reader (<a href="#zip-reading">zip.Reader</a>)</code></dt>
			<dd>The <code><a href="#zip-reading">zip.Reader</a></code> object used to read input data</dd>
			<dt><code>options (Object)</code></dt>
			<dd>Optional properties:
				<dl>
					<dt><code>checkSignature (boolean)</code></dt>
					<dd>boolean value specifying if the signature of all the files should be verified
						(<code>false</code> by default)</dd>
					<dt><code>password (string)</code></dt>
					<dd>password used to decrypt all the files (<code>undefined</code> by default)</dd>
					<dt><code>filenameEncoding (string)</code></dt>
					<dd>encoding of filenames stored in another encoding than UTF-8 (<code>cp437</code> by
						default)</dd>
					<dt><code>commentEncoding (string)</code></dt>
					<dd>encoding of comments stored in another encoding than UTF-8 (<code>cp437</code> by
						default)</dd>
					<dt><code>useWebWorkers (boolean)</code></dt>
					<dd>boolean value specifying if web workers should be used (<code>undefined</code> by default)</dd>
					<dt><code>signal (<a href="https://dom.spec.whatwg.org/#interface-AbortSignal">AbortSignal</a>)</code>
					</dt>
					<dd>signal object created with an <a
							href="https://dom.spec.whatwg.org/#dom-abortcontroller-abortcontroller">AbortController</a>
						instance and used to cancel the decompression</dd>
				</dl>
			</dd>
		</dl>
		<br>
		<h3>Methods</h3>
		<pre><code class="prettyprint">zip.ZipReader#getEntries([options])</code></pre>
		<p>
			Get all entries from a zip.
		</p>
		<p>Parameters:</p>
		<dl>
			<dt><code>options (Object)</code></dt>
			<dd>Optional properties:
				<dl>
					<dt><code>onprogress (Function)</code></dt>
					<dd>function tracking the task progress and having as parameters an <code>index (number)</code>
						value, a <code>max (number)</code> value (<code>undefined</code> by default) and the file entry
					</dd>
					<dt><code>filenameEncoding (string)</code></dt>
					<dd>encoding of filenames stored in another encoding than UTF-8 (<code>cp437</code> by
						default)</dd>
					<dt><code>commentEncoding (string)</code></dt>
					<dd>encoding of comments stored in another encoding than UTF-8 (<code>cp437</code> by
						default)</dd>
				</dl>
			</dd>
		</dl>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with the Array of <code><a href="#zip-entry">Entry</a></code> objects as resolved value</dd>
		</dl>
		<br>
		<pre><code class="prettyprint">zip.ZipReader#close()</code></pre>
		<p>
			Close the opened zip file.
		</p>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with <code>undefined</code> as resolved value</dd>
		</dl>

		<h3>Entry class</h3>
		<pre id="zip-entry"><code class="prettyprint">Entry()</code></pre>
		<p>
			Constructor representing a zip file entry
		</p>
		<h3>Attributes</h3>
		<dl>
			<dt><code>filename (string)</code></dt>
			<dd>file name</dd>
			<dt><code>rawFilename (UInt8Array)</code></dt>
			<dd>file name in binary format</dd>
			<dt><code>filenameUTF8 (boolean)</code></dt>
			<dd><code>true</code> if the filename is encoded in UTF-8</dd>
			<dt><code>directory (boolean)</code></dt>
			<dd><code>true</code> if the entry is a directory</dd>
			<dt><code>encrypted (boolean)</code></dt>
			<dd><code>true</code> if the entry is encrypted</dd>
			<dt><code>compressedSize (number)</code></dt>
			<dd>compressed data size</dd>
			<dt><code>uncompressedSize (number)</code></dt>
			<dd>uncompressed data size</dd>
			<dt><code>lastModDate (Date)</code></dt>
			<dd>last modification date</dd>
			<dt><code>lastAccessDate (Date)</code></dt>
			<dd>last access date (current date by default)</dd>
			<dt><code>creationDate (Date)</code></dt>
			<dd>creation date (current date by default)</dd>
			<dt><code>rawLastModDate (number)</code></dt>
			<dd>last modification date in binary format (MS-DOS)</dd>
			<dt><code>comment (string)</code></dt>
			<dd>file comment</dd>
			<dt><code>rawComment (UInt8Array)</code></dt>
			<dd>file comment in binary format</dd>
			<dt><code>commentUTF8 (boolean)</code></dt>
			<dd><code>true</code> if the comment is encoded in UTF-8</dd>
			<dt><code>extraField (Map)</code></dt>
			<dd>Map of extra field data where the key <code>(number)</code> is the type of the extra field and the value
				is a <code>UInt8Array</code></dd>
			<dt><code>rawExtraField (UInt8Array)</code></dt>
			<dd>extra field in binary format</dd>
			<dt><code>signature (Number or UInt8Array)</code></dt>
			<dd>signature (crc checksum or AES authentication code) of the file</dd>
			<dt><code>zip64 (boolean)</code></dt>
			<dd><code>true</code> if the file is formatted in Zip64</dd>
			<dt><code>compressionMethod (number)</code></dt>
			<dd>compression method</dd>
		</dl>
		<br>
		<h3>Methods</h3>
		<pre><code class="prettyprint">Entry#getData(writer [, options])</code></pre>
		<p>
			Get the data of a zip entry
		</p>
		<p>Parameters:</p>
		<dl>
			<dt><code>writer (<a href="#zip-writer">zip.Writer</a>)</code></dt>
			<dd>The <code><a href="#zip-writer">zip.Writer</a></code> object used to write output data</dd>
			<dt><code>options (Object)</code></dt>
			<dd>Optional properties:
				<dl>
					<dt><code>onprogress (Function)</code></dt>
					<dd>function tracking the task progress and having as parameters an <code>index (number)</code>
						value and a <code>max (number)</code> value (<code>undefined</code> by default)</dd>
					<dt><code>checkSignature (boolean)</code></dt>
					<dd>boolean value specifying if the signature of the file should be verified (<code>false</code> by
						default)</dd>
					<dt><code>password (string)</code></dt>
					<dd>password used to decrypt the file encrypted with AES or ZipCrypto (<code>undefined</code> by
						default)
					</dd>
					<dt><code>useWebWorkers (boolean)</code></dt>
					<dd>boolean value specifying if web workers should be used (<code>undefined</code> by default)</dd>
				</dl>
			</dd>
		</dl>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with the output data (returned type depends on
				<code><a href="#zip-writer">zip.Writer</a></code> constructor used) as resolved value
			</dd>
		</dl>

		<h2 id="zip-reading-example">ZipReader example</h2>
		<h3>Read a zip from a Blob/File object</h3>
		<pre><code class="prettyprint">// create a BlobReader to read with a ZipReader the zip from a Blob object
const reader = new zip.ZipReader(new zip.BlobReader(blob));

// get all entries from the zip
const entries = await reader.getEntries();
if (entries.length) {

  // get first entry content as text by using a TextWriter
  const text = await entries[0].getData(
    // writer
    new zip.TextWriter(),
    // options
    { 
      onprogress: (index, max) => {
         // onprogress callback
      }
    }
  );
  // text contains the entry data as a String
  console.log(text);

}

// close the ZipReader
await reader.close();</code></pre>

		<h2 id="zip-writing">ZipWriter class</h2>
		<h3>Constructor</h3>
		<pre><code class="prettyprint">zip.ZipWriter(writer [, options])</code></pre>
		<p>
			Create a <code><a href="#zip-writing">ZipWriter</a></code> object
		</p>
		<p>Parameters:</p>
		<dl>
			<dt><code>writer (<a href="#zip-writer">zip.Writer</a>)</code></dt>
			<dd>The <code><a href="#zip-writer">zip.Writer</a></code> object used to write output data</dd>
			<dt><code>options (Object)</code></dt>
			<dd>Optional properties:
				<dl>
					<dt><code>zip64 (boolean)</code></dt>
					<dd>force all the files to be written in Zip64 (<code>false</code> by default)</dd>
					<dt><code>level (number)</code></dt>
					<dd>compression level applied on all files (<code>5</code> by default)</dd>
					<dt><code>bufferedWrite (boolean)</code></dt>
					<dd><code>true</code> to explicitely allow calling <code>ZipWriter#add</code> multiple times in
						parallel (<code>false</code> by default)
					</dd>
					<dt><code>keepOrder (boolean)</code></dt>
					<dd><code>true</code> to keep the files in order when calling <code>ZipWriter#add</code> multiple
						times in parallel (<code>true</code> by default)
					</dd>
					<dt><code>lastModDate (Date)</code></dt>
					<dd>last modification date of all files (current date by default)</dd>
					<dt><code>lastAccessDate (Date)</code></dt>
					<dd>last access date of all files (current date by default)</dd>
					<dt><code>creationDate (Date)</code></dt>
					<dd>creation date of all files (current date by default)</dd>
					<dt><code>version (number)</code></dt>
					<dd>zip version of all files (<code>undefined</code> by default)</dd>
					<dt><code>versionMadeBy (number)</code></dt>
					<dd>"version made by" field of all files (<code>29</code> by default)</dd>
					<dt><code>password (string)</code></dt>
					<dd>password used to encrypt all the files (<code>undefined</code> by default)</dd>
					<dt><code>encryptionStrength (number)</code></dt>
					<dd>strength of the encryption algorithm: <code>1</code> for AES-128, <code>2</code> for AES-192,
						<code>3</code> for AES-256 (<code>3</code> by default)
					</dd>
					<dt><code>zipCrypto (boolean)</code></dt>
					<dd>use ZipCrypto instead of AES (<code>false</code> by default)
					</dd>
					<dt><code>useWebWorkers (boolean)</code></dt>
					<dd>boolean value specifying if web workers should be used (<code>undefined</code> by default)</dd>
					<dt><code>dataDescriptor (boolean)</code></dt>
					<dd>boolean value specifying the data descriptor record should be included (<code>true</code> by
						default)</dd>
					<dt><code>signal (<a href="https://dom.spec.whatwg.org/#interface-AbortSignal">AbortSignal</a>)</code>
					</dt>
					<dd>signal object created with an <a
							href="https://dom.spec.whatwg.org/#dom-abortcontroller-abortcontroller">AbortController</a>
						instance and used to cancel the compression</dd>
					<dt><code>internalFileAttribute (number)</code></dt>
					<dd>internal file attribute of all files (<code>undefined</code> by default)</dd>
					<dt><code>externalFileAttribute (number)</code></dt>
					<dd>external file attribute of all files (<code>undefined</code> by default)</dd>
				</dl>
			</dd>
		</dl>
		<br>
		<h3>Methods</h3>
		<pre><code class="prettyprint">zip.ZipWriter#add(name , reader [, options])</code></pre>
		<p>
			Add a new entry into the zip
		</p>
		<p>Parameters:</p>
		<dl>
			<dt><code>name (string)</code></dt>
			<dd>Entry file name</dd>
			<dt><code>reader (<a href="#zip-reading">zip.Reader</a>)</code></dt>
			<dd>The <code><a href="#zip-reading">zip.Reader</a></code> object used to read entry data to add -
				null for directory entry</dd>
			<dt><code>options (Object)</code></dt>
			<dd>Optional properties:
				<dl>
					<dt><code>onprogress (Function)</code></dt>
					<dd>function tracking the task progress and having as parameters an <code>index (number)</code>
						value and a <code>max (number)</code> value (<code>undefined</code> by default)</dd>
					<dt><code>directory (boolean)</code></dt>
					<dd><code>true</code> if the entry is a directory (<code>undefined</code> by default)</dd>
					<dt><code>level (number)</code></dt>
					<dd>compression level from <code>0</code> (no compression) to <code>9</code> (max. compression)
						(<code>5</code> by default)</dd>
					<dt><code>bufferedWrite (boolean)</code></dt>
					<dd><code>true</code> to explicitely allow calling <code>ZipWriter#add</code> multiple times in
						parallel (<code>false</code> by default)
					</dd>
					<dt><code>keepOrder (boolean)</code></dt>
					<dd><code>true</code> to keep the files in order when calling <code>ZipWriter#add</code> multiple
						times in parallel (<code>true</code> by default)
					</dd>
					<dt><code>comment (string)</code></dt>
					<dd>file comment (<code>undefined</code> by default)</dd>
					<dt><code>lastModDate (Date)</code></dt>
					<dd>last modification date (current date by default)</dd>
					<dt><code>lastAccessDate (Date)</code></dt>
					<dd>last access date (current date by default)</dd>
					<dt><code>creationDate (Date)</code></dt>
					<dd>creation date (current date by default)</dd>
					<dt><code>version (number)</code></dt>
					<dd>zip version (<code>undefined</code> by default)</dd>
					<dt><code>versionMadeBy (number)</code></dt>
					<dd>"version made by" field (<code>29</code> by default)</dd>
					<dt><code>password (string)</code></dt>
					<dd>password used to encrypt the file with AES or ZipCrypto (<code>undefined</code> by default)</dd>
					<dt><code>encryptionStrength (number)</code></dt>
					<dd>strength of the encryption algorithm: <code>1</code> for AES-128, <code>2</code> for AES-192,
						<code>3</code> for AES-256 (<code>3</code> by default)
					</dd>
					<dt><code>zipCrypto (boolean)</code></dt>
					<dd>use ZipCrypto instead of AES (<code>false</code> by default)
					</dd>
					<dt><code>zip64 (boolean)</code></dt>
					<dd>force the file entry to be written in Zip64 (<code>undefined</code> by default)</dd>
					<dt><code>extraField (Map)</code></dt>
					<dd>Map of extra field data where the key <code>(number)</code> is the type of the extra field and
						the value is a <code>UInt8Array</code> (<code>undefined</code> by default)</dd>
					<dt><code>useWebWorkers (boolean)</code></dt>
					<dd>boolean value specifying if web workers should be used (<code>undefined</code> by default)</dd>
					<dt><code>dataDescriptor (boolean)</code></dt>
					<dd>boolean value specifying the data descriptor record should be included (<code>true</code> by
						default)</dd>
					<dt><code>signal (<a href="https://dom.spec.whatwg.org/#interface-AbortSignal">AbortSignal</a>)</code>
					</dt>
					<dd>signal object created with an <a
							href="https://dom.spec.whatwg.org/#dom-abortcontroller-abortcontroller">AbortController</a>
						instance and used to cancel the compression</dd>
					<dt><code>internalFileAttribute (number)</code></dt>
					<dd>internal file attribute (<code>undefined</code> by default)</dd>
					<dt><code>externalFileAttribute (number)</code></dt>
					<dd>external file attribute (<code>undefined</code> by default)</dd>
				</dl>
			</dd>
		</dl>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with an <code><a href="#zip-entry">Entry</a></code> object as resolved value</dd>
		</dl>
		<br>
		<pre><code class="prettyprint">zip.ZipWriter#close([comment], [options])</code></pre>
		<p>
			Close the zip file
		</p>
		<p>Parameters:</p>
		<dl>
			<dt><code>comment (UInt8Array)</code></dt>
			<dd>A comment to add at the end of the zip file</dd>
			<dt><code>options (Object)</code></dt>
			<dd>Optional properties:
				<dl>
					<dt><code>onprogress (Function)</code></dt>
					<dd>function tracking the task progress and having as parameters an <code>index (number)</code>
						value, a <code>max (number)</code> value (<code>undefined</code> by default) and the file entry
					</dd>
					<dt><code>zip64 (boolean)</code></dt>
					<dd>force the file entry to be written in Zip64 (<code>undefined</code> by default)</dd>
				</dl>
			</dd>
		</dl>
		<p>Returns:</p>
		<dl>
			<dt><code>Promise</code></dt>
			<dd>A promise with the value of <code>writer.getData()</code> as resolved value</dd>
		</dl>

		<h2 id="zip-writing-example">ZipWriter example</h2>
		<h3>Write a zip into a Blob object</h3>
		<pre><code class="prettyprint">// use a BlobWriter to store with a ZipWriter the zip into a Blob object
const blobWriter = new zip.BlobWriter("application/zip");
const writer = new zip.ZipWriter(blobWriter);

// use a TextReader to read the String to add
await writer.add("filename.txt", new zip.TextReader("test!"));

// close the ZipReader
await writer.close();

// get the zip file as a Blob
const blob = await blobWriter.getData();</code></pre>
		<h2 id="full-example">Full example</h2>
		<pre><code class="prettyprint">// - create the inputBlob object storing the data to compress
const inputBlob = new Blob(
  ["Lorem ipsum dolor sit amet, consectetuer adipiscing elit..."], 
  { type: "text/plain" });

// - create a Data64URIWriter object to write the zipped data into a data URI
// - create a ZipWriter object with the Data64URIWriter object as parameter
const zipWriter = new zip.ZipWriter(new zip.Data64URIWriter("application/zip"));

// - create a BlobReader object to read the content of inputBlob
// - add a new file named "text.txt" in the zip and associate it to the BlobReader object
await zipWriter.add("test.txt", new zip.BlobReader(inputBlob));

// - close the ZipWriter object and get compressed data
const dataURI = await zipWriter.close();
// - log compressed data
console.log(dataURI);
// data:application/zip;base64,UEsDBBQACAgIAJuFO1IAAAAAAAAAAAAAAAAIAAAAdGVzdC50e...


// - create a Data64URIReader object with the zipped content 
// - create a ZipReader object to read the zipped data
const zipReader = new zip.ZipReader(new zip.Data64URIReader(dataURI));

// - get entries from the zip file
const entries = await zipReader.getEntries();

// - use a TextWriter object to write the unzipped data of the first entry into a string
const data = await entries[0].getData(new zip.TextWriter());
// - close the ZipReader object
await zipReader.close();

// - log data
console.log(data);
// Lorem ipsum dolor sit amet, consectetuer adipiscing elit...</code></pre>
		<p>You can find some other examples of code in the <a
				href="https://github.com/gildas-lormeau/zip.js/tree/master/tests" target="repository">/tests</a>
			and the <a href="https://github.com/gildas-lormeau/zip.js/tree/gh-pages/demos"
				target="repository">/demos</a> directories of the project.</p>
		<h2 id="alternative-codecs">Alternative DEFLATE implementations</h2>
		<p>Alternative DEFLATE implementations can be used with zip.js in favor of better performance and/or better
			compliance.
		</p>
		<ul>
			<li id="alternative-codec-pako">
				<h3>pako</h3>
				<p><a href="https://github.com/nodeca/pako">Pako</a> is a handwritten JavaScript port of zlib. Its
					compatibility and performance is believed to be good. To use pako, configure zip.js as follows:
				</p>
				<ul>
					<li>
						with web workers:
						<pre><code class="prettyprint">zip.configure({
  workerScripts: {
    deflate: ["library_path/z-worker-pako.js", "library_path/pako.min.js"],
    inflate: ["library_path/z-worker-pako.js", "library_path/pako.min.js"]
  }
});</code></pre>
						<p>Pako also has separate js files for deflating/inflating, you can also use them instead of
							<code>pako.min.js</code>:
						</p>
						<pre><code class="prettyprint">zip.configure({
  workerScripts: {
    deflate: ["library_path/z-worker-pako.js", "library_path/pako_deflate.min.js"],
    inflate: ["library_path/z-worker-pako.js", "library_path/pako_inflate.min.js"]
  }
});</code></pre>
						<p><code>library_path/z-worker-pako.js</code> is the entry script for pako. This file can
							be found in the <code>/dist/</code> directory</p>
					</li>
					<li>
						without web workers:
						<pre><code class="prettyprint">const { Deflate, Inflate } = 
  zip.initShimAsyncCodec(
    pako, 
    { deflate: { raw: true }, inflate: { raw: true } },
    (codec, onData) => codec.onData = onData
  );

zip.configure({
  useWebWorkers: false,
  Deflate,
  Inflate
});</code></pre>
					</li>
				</ul>

				<p>Note that <code>pako.min.js</code> etc. are parts of pako project, and are not provided by zip.js.
					You can find them <a href="https://github.com/nodeca/pako/tree/master/dist">here</a>.
				</p>
			</li>
			<li id="alternative-codec-fflate">
				<h3>fflate</h3>
				<p><a href="https://github.com/101arrowz/fflate">fflate</a> claims to be the fastest, smallest, and most
					versatile pure JavaScript compression and decompression library in existence. To use fflate,
					configure zip.js as follows:
				</p>
				<ul>
					<li>
						with web workers:
						<pre><code class="prettyprint">zip.configure({
  workerScripts: {
    deflate: ["library_path/z-worker-fflate.js", "library_path/fflate.min.js"],
    inflate: ["library_path/z-worker-fflate.js", "library_path/fflate.min.js"]
  }
});</code></pre>
						<p><code>library_path/z-worker-fflate.js</code> is the entry script for fflate. This file can
							be found in the <code>/dist/</code> directory</p>
					</li>
					<li>
						without web workers:
						<pre><code class="prettyprint">const { Deflate, Inflate } = 
  zip.initShimAsyncCodec(
    fflate, 
    undefined, 
    (codec, onData) => codec.ondata = onData
  );

zip.configure({
  useWebWorkers: false,
  Deflate,
  Inflate
});</code></pre>
					</li>
				</ul>
				<p>Note that <code>fflate.min.js</code> is part of fflate project, and is not provided by zip.js. You
					can download it <a href="https://cdn.jsdelivr.net/npm/fflate/umd/index.js">here</a>.
				</p>
			</li>
		</ul>

	</div>
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	<script type="text/javascript">
		prettyPrint();
	</script>
</body>

</html>