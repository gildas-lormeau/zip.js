(t=>{"use strict";const n="Invalid pasword",r=16,i={name:"PBKDF2"},s={name:"HMAC"},e="SHA-1",a={name:"AES-CTR"},u=Object.assign({hash:s},i),h=Object.assign({iterations:1e3,hash:{name:e}},i),o=Object.assign({hash:e},s),c=Object.assign({length:r},a),y=["deriveBits"],p=["sign"],w=528,g=10,l=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],d=crypto.subtle;function b(t){for(let n=0;n<16;n++){if(255!=t[n]){t[n]++;break}t[n]=0}}function A(t,n){let r=t;return t.length+n.length&&(r=new Uint8Array(t.length+n.length),r.set(t,0),r.set(n,t.length)),r}function U(t,n){if(n&&n>t.length){const r=t;(t=new Uint8Array(n)).set(r,0)}return t}t.ZipDecrypt=class{constructor(t,n){this.password=t,this.signed=n,this.input=n&&new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const i=async(n=0)=>{if(n+r<e.length-g){const t=e.subarray(n,n+r),a=await d.decrypt(Object.assign({counter:this.counter},c),this.keys.decryption,t);return b(this.counter),s.set(new Uint8Array(a),n),i(n+r)}return this.pendingInput=e.subarray(n),this.signed&&(this.input=A(this.input,t)),s};if(this.password){const r=t.subarray(0,18);await async function(t,r,i){t.counter=new Uint8Array(l);const s=r.subarray(0,16),e=r.subarray(16),c=(new TextEncoder).encode(i),w=await d.importKey("raw",c,u,!1,y),g=await d.deriveBits(Object.assign({salt:s},h),w,528),b=new Uint8Array(g),A=b.subarray(64);if(t.keys={decryption:await d.importKey("raw",b.subarray(0,32),a,!0,["decrypt"]),authentication:await d.importKey("raw",b.subarray(32,64),o,!1,p),passwordVerification:A},A[0]!=e[0]||A[1]!=e[1])throw new Error(n)}(this,r,this.password),this.password=null,t=t.subarray(18)}let s=new Uint8Array(t.length-g-(t.length-g)%r),e=t;return this.pendingInput.length&&(e=A(this.pendingInput,t),s=U(s,e.length-g-(e.length-g)%r)),i()}async flush(){const t=this.pendingInput,n=this.keys,r=t.subarray(0,t.length-g),i=t.subarray(t.length-g);let e=new Uint8Array(0);if(r.length){const t=await d.decrypt(Object.assign({counter:this.counter},c),n.decryption,r);e=new Uint8Array(t)}let a=!0;if(this.signed){const t=await d.sign(s,n.authentication,this.input.subarray(0,this.input.length-g)),r=new Uint8Array(t);this.input=null;for(let t=0;t<g;t++)r[t]!=i[t]&&(a=!1)}return{valid:a,data:e}}},t.ZipEncrypt=class{constructor(t){this.password=t,this.output=new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const n=async(e=0)=>{if(e+r<=t.length){const a=t.subarray(e,e+r),u=await d.encrypt(Object.assign({counter:this.counter},c),this.keys.encryption,a);return b(this.counter),s.set(new Uint8Array(u),e+i.length),n(e+r)}return this.pendingInput=t.subarray(e),this.output=A(this.output,s),s};let i=new Uint8Array(0);this.password&&(i=await async function(t,n){t.counter=new Uint8Array(l);const r=crypto.getRandomValues(new Uint8Array(16)),i=(new TextEncoder).encode(n),s=await d.importKey("raw",i,u,!1,y),e=await d.deriveBits(Object.assign({salt:r},h),s,w),c=new Uint8Array(e);return t.keys={encryption:await d.importKey("raw",c.subarray(0,32),a,!0,["encrypt"]),authentication:await d.importKey("raw",c.subarray(32,64),o,!1,p),passwordVerification:c.subarray(64)},A(r,t.keys.passwordVerification)}(this,this.password),this.password=null);let s=new Uint8Array(i.length+t.length-t.length%r);return s.set(i,0),this.pendingInput.length&&(t=A(this.pendingInput,t),s=U(s,t.length-t.length%r)),n()}async flush(){let t=new Uint8Array(0);if(this.pendingInput.length){const n=await d.encrypt(Object.assign({counter:this.counter},c),this.keys.encryption,this.pendingInput);t=new Uint8Array(n),this.output=A(this.output,t)}const n=await d.sign(s,this.keys.authentication,this.output.subarray(18));this.output=null;const r=new Uint8Array(n).subarray(0,g);return{data:A(t,r),signature:r}}}})(this);
