!function(){"use strict";const t=[];for(let e=0;e<256;e++){let n=e;for(let t=0;t<8;t++)1&n?n=n>>>1^3988292384:n>>>=1;t[e]=n}class e{constructor(t){this.crc=t||-1}append(e){let n=0|this.crc;for(let s=0,i=0|e.length;s<i;s++)n=n>>>8^t[255&(n^e[s])];this.crc=n}get(){return~this.crc}}const n="Invalid pasword",s=16,i="raw",r={name:"PBKDF2"},a={name:"HMAC"},h="SHA-1",c={name:"AES-CTR"},o=Object.assign({hash:a},r),p=Object.assign({iterations:1e3,hash:{name:h}},r),d=Object.assign({hash:h},a),y=Object.assign({length:s},c),u=["deriveBits"],l=["sign"],g=[8,12,16],w=[16,24,32],f=10,A=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],U=crypto.subtle;class b{constructor(t,e,n){this.password=t,this.signed=e,this.strength=n-1,this.input=e&&new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const e=async(n=0)=>{if(n+s<=r.length-f){const t=r.subarray(n,n+s),a=await U.decrypt(Object.assign({counter:this.counter},y),this.keys.key,t);return I(this.counter),i.set(new Uint8Array(a),n),e(n+s)}return this.pendingInput=r.subarray(n),this.signed&&(this.input=C(this.input,t)),i};if(this.password){const e=t.subarray(0,g[this.strength]+2);await async function(t,e,s){await m(t,s,e.subarray(0,g[t.strength]),["decrypt"]);const i=e.subarray(g[t.strength]),r=t.keys.passwordVerification;if(r[0]!=i[0]||r[1]!=i[1])throw new Error(n)}(this,e,this.password),this.password=null,t=t.subarray(g[this.strength]+2)}let i=new Uint8Array(t.length-f-(t.length-f)%s),r=t;return this.pendingInput.length&&(r=C(this.pendingInput,t),i=D(i,r.length-f-(r.length-f)%s)),e()}async flush(){const t=this.pendingInput,e=this.keys,n=t.subarray(0,t.length-f),s=t.subarray(t.length-f);let i=new Uint8Array(0);if(n.length){const t=await U.decrypt(Object.assign({counter:this.counter},y),e.key,n);i=new Uint8Array(t)}let r=!0;if(this.signed){const t=await U.sign(a,e.authentication,this.input.subarray(0,this.input.length-f)),n=new Uint8Array(t);this.input=null;for(let t=0;t<f;t++)n[t]!=s[t]&&(r=!1)}return{valid:r,data:i}}}class k{constructor(t,e){this.password=t,this.strength=e-1,this.output=new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){const e=async(r=0)=>{if(r+s<=t.length){const a=t.subarray(r,r+s),h=await U.encrypt(Object.assign({counter:this.counter},y),this.keys.key,a);return I(this.counter),i.set(new Uint8Array(h),r+n.length),e(r+s)}return this.pendingInput=t.subarray(r),this.output=C(this.output,i),i};let n=new Uint8Array(0);this.password&&(n=await async function(t,e){const n=crypto.getRandomValues(new Uint8Array(g[t.strength]));return await m(t,e,n,["encrypt"]),C(n,t.keys.passwordVerification)}(this,this.password),this.password=null);let i=new Uint8Array(n.length+t.length-t.length%s);return i.set(n,0),this.pendingInput.length&&(t=C(this.pendingInput,t),i=D(i,t.length-t.length%s)),e()}async flush(){let t=new Uint8Array(0);if(this.pendingInput.length){const e=await U.encrypt(Object.assign({counter:this.counter},y),this.keys.key,this.pendingInput);t=new Uint8Array(e),this.output=C(this.output,t)}const e=await U.sign(a,this.keys.authentication,this.output.subarray(g[this.strength]+2));this.output=null;const n=new Uint8Array(e).subarray(0,f);return{data:C(t,n),signature:n}}}async function m(t,e,n,s){t.counter=new Uint8Array(A);const r=(new TextEncoder).encode(e),a=await U.importKey(i,r,o,!1,u),h=await U.deriveBits(Object.assign({salt:n},p),a,8*(2*w[t.strength]+2)),y=new Uint8Array(h);t.keys={key:await U.importKey(i,y.subarray(0,w[t.strength]),c,!0,s),authentication:await U.importKey(i,y.subarray(w[t.strength],2*w[t.strength]),d,!1,l),passwordVerification:y.subarray(2*w[t.strength])}}function I(t){for(let e=0;e<16;e++){if(255!=t[e]){t[e]++;break}t[e]=0}}function C(t,e){let n=t;return t.length+e.length&&(n=new Uint8Array(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function D(t,e){if(e&&e>t.length){const n=t;(t=new Uint8Array(e)).set(n,0)}return t}const v=12;class V{constructor(t,e){this.password=t,this.passwordVerification=e,O(this,t)}async append(t){if(this.password){const e=z(this,t.subarray(0,v));if(this.password=null,e[11]!=this.passwordVerification)throw new Error(n);t=t.subarray(v)}return z(this,t)}async flush(){return{valid:!0,data:new Uint8Array(0)}}}class j{constructor(t,e){this.passwordVerification=e,this.password=t,O(this,t)}async append(t){let e,n;if(this.password){this.password=null;const s=crypto.getRandomValues(new Uint8Array(v));s[11]=this.passwordVerification,e=new Uint8Array(t.length+s.length),e.set(K(this,s),0),n=v}else e=new Uint8Array(t.length),n=0;return e.set(K(this,t),n),e}async flush(){return{data:new Uint8Array(0)}}}function z(t,e){const n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=M(t)^e[s],E(t,n[s]);return n}function K(t,e){const n=new Uint8Array(e.length);for(let s=0;s<e.length;s++)n[s]=M(t)^e[s],E(t,e[s]);return n}function O(t,n){t.keys=[305419896,591751049,878082192],t.crcKey0=new e(t.keys[0]),t.crcKey2=new e(t.keys[2]);for(let e=0;e<n.length;e++)E(t,n.charCodeAt(e))}function E(t,e){t.crcKey0.append([e]),t.keys[0]=~t.crcKey0.get(),t.keys[1]=S(t.keys[1]+T(t.keys[0])),t.keys[1]=S(Math.imul(t.keys[1],134775813)+1),t.crcKey2.append([t.keys[1]>>>24]),t.keys[2]=~t.crcKey2.get()}function M(t){const e=2|t.keys[2];return T(Math.imul(e,1^e)>>>8)}function T(t){return 255&t}function S(t){return 4294967295&t}const B="deflate",W="inflate",R="Invalid signature";class H{constructor(t,n){this.signature=n.signature,this.encrypted=Boolean(n.password),this.signed=n.signed,this.compressed=n.compressed,this.inflate=n.compressed&&new t,this.crc32=n.signed&&new e,this.zipCrypto=n.zipCrypto,this.decrypt=this.encrypted&&n.zipCrypto?new V(n.password,n.passwordVerification):new b(n.password,n.signed,n.encryptionStrength)}async append(t){return this.encrypted&&t.length&&(t=await this.decrypt.append(t)),this.compressed&&t.length&&(t=await this.inflate.append(t)),(!this.encrypted||this.zipCrypto)&&this.signed&&t.length&&this.crc32.append(t),t}async flush(){let t,e=new Uint8Array(0);if(this.encrypted){const t=await this.decrypt.flush();if(!t.valid)throw new Error(R);e=t.data}if((!this.encrypted||this.zipCrypto)&&this.signed){const e=new DataView(new Uint8Array(4).buffer);if(t=this.crc32.get(),e.setUint32(0,t),this.signature!=e.getUint32(0,!1))throw new Error(R)}return this.compressed&&(e=await this.inflate.append(e)||new Uint8Array(0),await this.inflate.flush()),{data:e,signature:t}}}class x{constructor(t,n){this.encrypted=n.encrypted,this.signed=n.signed,this.compressed=n.compressed,this.deflate=n.compressed&&new t({level:n.level||5}),this.crc32=n.signed&&new e,this.zipCrypto=n.zipCrypto,this.encrypt=this.encrypted&&n.zipCrypto?new j(n.password,n.passwordVerification):new k(n.password,n.encryptionStrength)}async append(t){let e=t;return this.compressed&&t.length&&(e=await this.deflate.append(t)),this.encrypted&&e.length&&(e=await this.encrypt.append(e)),(!this.encrypted||this.zipCrypto)&&this.signed&&t.length&&this.crc32.append(t),e}async flush(){let t,e=new Uint8Array(0);if(this.compressed&&(e=await this.deflate.flush()||new Uint8Array(0)),this.encrypted){e=await this.encrypt.append(e);const n=await this.encrypt.flush();t=n.signature;const s=new Uint8Array(e.length+n.data.length);s.set(e,0),s.set(n.data,e.length),e=s}return this.encrypted&&!this.zipCrypto||!this.signed||(t=this.crc32.get()),{data:e,signature:t}}}const F={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let n;self.initCodec&&self.initCodec(),e.codecType.startsWith(B)?n=self.Deflate:e.codecType.startsWith(W)&&(n=self.Inflate),L=function(t,e){return e.codecType.startsWith(B)?new x(t,e):e.codecType.startsWith(W)?new H(t,e):void 0}(n,e)},append:async t=>({data:await L.append(t.data)}),flush:()=>L.flush()};let L;addEventListener("message",(async t=>{const e=t.data,n=e.type,s=F[n];if(s)try{e.data&&(e.data=new Uint8Array(e.data));const t=await s(e)||{};if(t.type=n,t.data)try{t.data=t.data.buffer,postMessage(t,[t.data])}catch(e){postMessage(t)}else postMessage(t)}catch(t){postMessage({type:n,error:{message:t.message,stack:t.stack}})}}));function P(t,e,n){return class{constructor(s){this.codec=new t(Object.assign({},e,s)),n(this.codec,(t=>{if(this.pendingData){const e=this.pendingData;this.pendingData=new Uint8Array(e.length+t.length),this.pendingData.set(e,0),this.pendingData.set(t,e.length)}else this.pendingData=new Uint8Array(t)}))}async append(t){return this.codec.push(t),s(this)}async flush(){return this.codec.push(new Uint8Array(0),!0),s(this)}};function s(t){if(t.pendingData){const e=t.pendingData;return t.pendingData=null,e}return new Uint8Array(0)}}self.initCodec=()=>{const{Deflate:t,Inflate:e}=((t,e={},n)=>({Deflate:P(t.Deflate,e.deflate,n),Inflate:P(t.Inflate,e.inflate,n)}))(fflate,void 0,((t,e)=>t.ondata=e));self.Deflate=t,self.Inflate=e}}();
